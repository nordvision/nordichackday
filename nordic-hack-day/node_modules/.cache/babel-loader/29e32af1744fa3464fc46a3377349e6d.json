{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\n\nvar _createClass = function () {\n  function e(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n    }\n  }\n\n  return function (r, t, o) {\n    return t && e(r.prototype, t), o && e(r, o), r;\n  };\n}(),\n    _propTypes = require(\"prop-types\"),\n    _propTypes2 = _interopRequireDefault(_propTypes),\n    _reactLeaflet = require(\"react-leaflet\"),\n    _leaflet = require(\"leaflet\"),\n    _leaflet2 = _interopRequireDefault(_leaflet),\n    _deepEqual = require(\"deep-equal\"),\n    _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    default: e\n  };\n}\n\nfunction _classCallCheck(e, r) {\n  if (!(e instanceof r)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _possibleConstructorReturn(e, r) {\n  if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return !r || \"object\" != typeof r && \"function\" != typeof r ? e : r;\n}\n\nfunction _inherits(e, r) {\n  if (\"function\" != typeof r && null !== r) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof r);\n  e.prototype = Object.create(r && r.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(e, r) : e.__proto__ = r);\n}\n\nfunction havingDeprecatedProps(e) {\n  return -1 !== e.findIndex(function (e) {\n    return e.lat || e.lng;\n  });\n}\n\nfunction isArraysEqual(e, r) {\n  return e.length === r.length && (0, _deepEqual2.default)(e, r);\n}\n\nfunction removeMarkersWithSameCoordinates(e) {\n  var r = [e[0]];\n  return e.forEach(function (e) {\n    JSON.stringify(r).includes(JSON.stringify(e)) || r.push(e);\n  }), r;\n}\n\nrequire(\"leaflet.markercluster\");\n\nvar MarkerClusterGroup = function (e) {\n  function r() {\n    return _classCallCheck(this, r), _possibleConstructorReturn(this, (r.__proto__ || Object.getPrototypeOf(r)).apply(this, arguments));\n  }\n\n  return _inherits(r, _reactLeaflet.LayerGroup), _createClass(r, [{\n    key: \"componentWillMount\",\n    value: function () {\n      var e = this.props,\n          r = e.markers,\n          t = e.options;\n      t && console.warn('[react-leaflet-markercluster] Warning: \"options\" property is deprecated and will be removed in v1.2.0. Please see: https://goo.gl/pq3oM7'), this.leafletElement = _leaflet2.default.markerClusterGroup(t || this.props), this.initMapClasses(), r.length && (this.addLayersWithMarkersFromProps(r), havingDeprecatedProps(r) && console.warn('[react-leaflet-markercluster] Warning: marker \"lat: xx\", \"lng: xx\" properties are deprecated and will be removed in v1.2.0. Please use \"position: [lat, lng]\" instead https://goo.gl/s7a6Cj')), this.initEventListeners(this.leafletElement);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function (e) {\n      isArraysEqual(this.props.markers, e.markers) || (this.leafletElement.clearLayers(), e.markers.length && this.addLayersWithMarkersFromProps(e.markers));\n    }\n  }, {\n    key: \"initMapClasses\",\n    value: function () {\n      this.props.wrapperOptions && console.warn('[react-leaflet-markercluster] Warning: \"wrapperOptions\" property is deprecated and has been removed in v1.1.8. Please see: https://goo.gl/pq3oM7');\n    }\n  }, {\n    key: \"addLayersWithMarkersFromProps\",\n    value: function (e) {\n      var r = this.props,\n          t = r.markerOptions,\n          o = r.wrapperOptions,\n          n = t ? Object.assign({}, t) : {},\n          a = [];\n      (o && o.removeDuplicates ? removeMarkersWithSameCoordinates(e) : e).forEach(function (e) {\n        var r = e.options ? Object.assign({}, e.options) : null,\n            t = _leaflet2.default.marker(e.position || [e.lat, e.lng], r || n);\n\n        e.popup && t.bindPopup(e.popup), e.tooltip && t.bindTooltip(e.tooltip), a.push(t);\n      }), this.leafletElement.addLayers(a);\n    }\n  }, {\n    key: \"initEventListeners\",\n    value: function (e) {\n      var r = this;\n      this.props.onMarkerClick && e.on(\"click\", function (e) {\n        r.props.onMarkerClick(e.layer);\n      }), this.props.onClusterClick && e.on(\"clusterclick\", function (e) {\n        r.props.onClusterClick(e.layer);\n      }), this.props.onPopupClose && e.on(\"popupclose\", function (e) {\n        r.props.onPopupClose(e.popup);\n      });\n    }\n  }, {\n    key: \"getLeafletElement\",\n    value: function () {\n      return this.leafletElement;\n    }\n  }, {\n    key: \"getChildContext\",\n    value: function () {\n      return {\n        layerContainer: this.leafletElement\n      };\n    }\n  }, {\n    key: \"createLeafletElement\",\n    value: function (e) {\n      return new _leaflet2.default.markerClusterGroup(e.options || e);\n    }\n  }]), r;\n}();\n\nexports.default = MarkerClusterGroup, MarkerClusterGroup.propTypes = {\n  markers: _propTypes2.default.arrayOf(_propTypes2.default.object),\n  children: _propTypes2.default.node,\n  options: _propTypes2.default.object,\n  markerOptions: _propTypes2.default.object,\n  wrapperOptions: _propTypes2.default.object,\n  onMarkerClick: _propTypes2.default.func,\n  onClusterClick: _propTypes2.default.func,\n  onPopupClose: _propTypes2.default.func\n}, MarkerClusterGroup.defaultProps = {\n  markers: []\n};","map":null,"metadata":{},"sourceType":"script"}