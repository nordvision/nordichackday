{"ast":null,"code":"import _defineProperty from \"/Users/n642407/Repos/NordicHackDay/nordic-hack-day/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"/Users/n642407/Repos/NordicHackDay/nordic-hack-day/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _jsxFileName = \"/Users/n642407/Repos/NordicHackDay/nordic-hack-day/src/Extra/Map.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { latLngBounds, Map as LeafletMap } from 'leaflet';\nimport React from 'react';\nimport { LeafletProvider } from './context';\nimport MapEvented from './MapEvented';\nimport updateClassName from './utils/updateClassName';\nimport omit from './utils/omit';\nconst OTHER_PROPS = ['children', 'className', 'id', 'style', 'useFlyTo', 'whenReady'];\n\nconst normalizeCenter = pos => {\n  return Array.isArray(pos) ? [pos[0], pos[1]] : [pos.lat, pos.lon ? pos.lon : pos.lng];\n};\n\nexport default class Map extends MapEvented {\n  constructor(props) {\n    super(props);\n    this.viewport = {\n      center: undefined,\n      zoom: undefined\n    };\n    this._ready = false;\n    this._updating = false;\n\n    this.onViewportChange = () => {\n      const center = this.leafletElement.getCenter();\n      this.viewport = {\n        center: center ? [center.lat, center.lng] : undefined,\n        zoom: this.leafletElement.getZoom()\n      };\n\n      if (this.props.onViewportChange && !this._updating) {\n        this.props.onViewportChange(this.viewport);\n      }\n    };\n\n    this.onViewportChanged = () => {\n      if (this.props.onViewportChanged && !this._updating) {\n        this.props.onViewportChanged(this.viewport);\n      }\n    };\n\n    this.bindContainer = container => {\n      this.container = container;\n    };\n\n    this.className = props.className;\n  }\n\n  createLeafletElement(props) {\n    const viewport = props.viewport,\n          options = _objectWithoutProperties(props, [\"viewport\"]);\n\n    if (viewport) {\n      if (viewport.center) {\n        options.center = viewport.center;\n      }\n\n      if (typeof viewport.zoom === 'number') {\n        options.zoom = viewport.zoom;\n      }\n    }\n\n    return new LeafletMap(this.container, options);\n  }\n\n  updateLeafletElement(fromProps, toProps) {\n    this._updating = true;\n    const bounds = toProps.bounds,\n          boundsOptions = toProps.boundsOptions,\n          boxZoom = toProps.boxZoom,\n          center = toProps.center,\n          className = toProps.className,\n          doubleClickZoom = toProps.doubleClickZoom,\n          dragging = toProps.dragging,\n          keyboard = toProps.keyboard,\n          maxBounds = toProps.maxBounds,\n          scrollWheelZoom = toProps.scrollWheelZoom,\n          tap = toProps.tap,\n          touchZoom = toProps.touchZoom,\n          useFlyTo = toProps.useFlyTo,\n          viewport = toProps.viewport,\n          zoom = toProps.zoom;\n    updateClassName(this.container, fromProps.className, className);\n\n    if (viewport && viewport !== fromProps.viewport) {\n      const c = viewport.center ? viewport.center : center;\n      const z = viewport.zoom == null ? zoom : viewport.zoom;\n\n      if (useFlyTo === true) {\n        this.leafletElement.flyTo(c, z, this.getZoomPanOptions(toProps));\n      } else {\n        this.leafletElement.setView(c, z, this.getZoomPanOptions(toProps));\n      }\n    } else if (center && this.shouldUpdateCenter(center, fromProps.center)) {\n      if (useFlyTo === true) {\n        this.leafletElement.flyTo(center, zoom, this.getZoomPanOptions(toProps));\n      } else {\n        this.leafletElement.setView(center, zoom, this.getZoomPanOptions(toProps));\n      }\n    } else if (typeof zoom === 'number' && zoom !== fromProps.zoom) {\n      if (fromProps.zoom == null) {\n        this.leafletElement.setView(center, zoom, this.getZoomPanOptions(toProps));\n      } else {\n        this.leafletElement.setZoom(zoom, this.getZoomPanOptions(toProps));\n      }\n    }\n\n    if (maxBounds && this.shouldUpdateBounds(maxBounds, fromProps.maxBounds)) {\n      this.leafletElement.setMaxBounds(maxBounds);\n    }\n\n    if (bounds && (this.shouldUpdateBounds(bounds, fromProps.bounds) || boundsOptions !== fromProps.boundsOptions)) {\n      if (useFlyTo === true) {\n        this.leafletElement.flyToBounds(bounds, this.getFitBoundsOptions(toProps));\n      } else {\n        this.leafletElement.fitBounds(bounds, this.getFitBoundsOptions(toProps));\n      }\n    }\n\n    if (boxZoom !== fromProps.boxZoom) {\n      if (boxZoom === true) {\n        this.leafletElement.boxZoom.enable();\n      } else {\n        this.leafletElement.boxZoom.disable();\n      }\n    }\n\n    if (doubleClickZoom !== fromProps.doubleClickZoom) {\n      if (doubleClickZoom === true) {\n        this.leafletElement.doubleClickZoom.enable();\n      } else {\n        this.leafletElement.doubleClickZoom.disable();\n      }\n    }\n\n    if (dragging !== fromProps.dragging) {\n      if (dragging === true) {\n        this.leafletElement.dragging.enable();\n      } else {\n        this.leafletElement.dragging.disable();\n      }\n    }\n\n    if (keyboard !== fromProps.keyboard) {\n      if (keyboard === true) {\n        this.leafletElement.keyboard.enable();\n      } else {\n        this.leafletElement.keyboard.disable();\n      }\n    }\n\n    if (scrollWheelZoom !== fromProps.scrollWheelZoom) {\n      if (scrollWheelZoom === true || typeof scrollWheelZoom === 'string') {\n        this.leafletElement.options.scrollWheelZoom = scrollWheelZoom;\n        this.leafletElement.scrollWheelZoom.enable();\n      } else {\n        this.leafletElement.scrollWheelZoom.disable();\n      }\n    }\n\n    if (tap !== fromProps.tap) {\n      if (tap === true) {\n        this.leafletElement.tap.enable();\n      } else {\n        this.leafletElement.tap.disable();\n      }\n    }\n\n    if (touchZoom !== fromProps.touchZoom) {\n      if (touchZoom === true || typeof touchZoom === 'string') {\n        this.leafletElement.options.touchZoom = touchZoom;\n        this.leafletElement.touchZoom.enable();\n      } else {\n        this.leafletElement.touchZoom.disable();\n      }\n    }\n\n    this._updating = false;\n  }\n\n  getZoomPanOptions(props) {\n    const animate = props.animate,\n          duration = props.duration,\n          easeLinearity = props.easeLinearity,\n          noMoveStart = props.noMoveStart;\n    return {\n      animate,\n      duration,\n      easeLinearity,\n      noMoveStart\n    };\n  }\n\n  getFitBoundsOptions(props) {\n    const zoomPanOptions = this.getZoomPanOptions(props);\n    return _objectSpread({}, zoomPanOptions, {}, props.boundsOptions);\n  }\n\n  componentDidMount() {\n    const props = omit(this.props, ...OTHER_PROPS);\n    this.leafletElement = this.createLeafletElement(props);\n    this.leafletElement.on('move', this.onViewportChange);\n    this.leafletElement.on('moveend', this.onViewportChanged);\n\n    if (props.bounds != null) {\n      this.leafletElement.fitBounds(props.bounds, this.getFitBoundsOptions(props));\n    }\n\n    this.contextValue = {\n      layerContainer: this.leafletElement,\n      map: this.leafletElement\n    };\n    super.componentDidMount();\n    this.forceUpdate(); // Re-render now that leafletElement is created\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this._ready === false) {\n      this._ready = true;\n\n      if (this.props.whenReady) {\n        this.leafletElement.whenReady(this.props.whenReady);\n      }\n    }\n\n    super.componentDidUpdate(prevProps);\n    this.updateLeafletElement(prevProps, this.props);\n  }\n\n  componentWillUnmount() {\n    super.componentWillUnmount();\n    this.leafletElement.off('move', this.onViewportChange);\n    this.leafletElement.off('moveend', this.onViewportChanged); // The canvas renderer uses requestAnimationFrame, making a deferred call to a deleted object\n    // When preferCanvas is set, use simpler teardown logic\n\n    if (this.props.preferCanvas === true) {\n      this.leafletElement._initEvents(true);\n\n      this.leafletElement._stop();\n    } else {\n      this.leafletElement.remove();\n    }\n  }\n\n  shouldUpdateCenter(next, prev) {\n    if (!prev) return true;\n    next = normalizeCenter(next);\n    prev = normalizeCenter(prev);\n    return next[0] !== prev[0] || next[1] !== prev[1];\n  }\n\n  shouldUpdateBounds(next, prev) {\n    return prev ? !latLngBounds(next).equals(latLngBounds(prev)) : true;\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      className: this.className,\n      id: this.props.id,\n      ref: this.bindContainer,\n      style: this.props.style,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 367\n      },\n      __self: this\n    }, this.contextValue ? React.createElement(LeafletProvider, {\n      value: this.contextValue,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 373\n      },\n      __self: this\n    }, this.props.children) : null);\n  }\n\n}","map":{"version":3,"sources":["/Users/n642407/Repos/NordicHackDay/nordic-hack-day/src/Extra/Map.js"],"names":["latLngBounds","Map","LeafletMap","React","LeafletProvider","MapEvented","updateClassName","omit","OTHER_PROPS","normalizeCenter","pos","Array","isArray","lat","lon","lng","constructor","props","viewport","center","undefined","zoom","_ready","_updating","onViewportChange","leafletElement","getCenter","getZoom","onViewportChanged","bindContainer","container","className","createLeafletElement","options","updateLeafletElement","fromProps","toProps","bounds","boundsOptions","boxZoom","doubleClickZoom","dragging","keyboard","maxBounds","scrollWheelZoom","tap","touchZoom","useFlyTo","c","z","flyTo","getZoomPanOptions","setView","shouldUpdateCenter","setZoom","shouldUpdateBounds","setMaxBounds","flyToBounds","getFitBoundsOptions","fitBounds","enable","disable","animate","duration","easeLinearity","noMoveStart","zoomPanOptions","componentDidMount","on","contextValue","layerContainer","map","forceUpdate","componentDidUpdate","prevProps","whenReady","componentWillUnmount","off","preferCanvas","_initEvents","_stop","remove","next","prev","equals","render","id","style","children"],"mappings":"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","sourcesContent":["// @flow\n\nimport {\n  latLngBounds,\n  Map as LeafletMap,\n  type CRS,\n  type Renderer,\n} from 'leaflet'\nimport React, { type Node } from 'react'\n\nimport { LeafletProvider } from './context'\nimport MapEvented from './MapEvented'\nimport updateClassName from './utils/updateClassName'\nimport omit from './utils/omit'\nimport type {\n  LatLng,\n  LatLngBounds,\n  LeafletContext,\n  Point,\n  Viewport,\n} from './types'\n\nconst OTHER_PROPS = [\n  'children',\n  'className',\n  'id',\n  'style',\n  'useFlyTo',\n  'whenReady',\n]\n\nconst normalizeCenter = (pos: LatLng): [number, number] => {\n  return Array.isArray(pos)\n    ? [pos[0], pos[1]]\n    : [pos.lat, pos.lon ? pos.lon : pos.lng]\n}\n\ntype LeafletElement = LeafletMap\n\ntype ZoomOption = boolean | 'center'\ntype Props = {\n  [key: string]: any,\n  // Leaflet options\n  preferCanvas?: boolean,\n  attributionControl?: boolean,\n  zoomControl?: boolean,\n  closePopupOnClick?: boolean,\n  zoomSnap?: number,\n  zoomDelta?: number,\n  trackResize?: boolean,\n  boxZoom?: boolean,\n  doubleClickZoom?: ZoomOption,\n  dragging?: boolean,\n  crs?: CRS,\n  center?: LatLng,\n  zoom?: number,\n  minZoom?: number,\n  maxZoom?: number,\n  maxBounds?: LatLngBounds,\n  renderer?: Renderer,\n  zoomAnimation?: boolean,\n  zoomAnimationThreshold?: number,\n  fadeAnimation?: boolean,\n  markerZoomAnimation?: boolean,\n  transform3DLimit?: number,\n  inertia?: boolean,\n  inertiaDeceleration?: number,\n  inertiaMaxSpeed?: number,\n  easeLinearity?: number,\n  worldCopyJump?: boolean,\n  maxBoundsViscosity?: number,\n  keyboard?: boolean,\n  keyboardPanDelta?: number,\n  scrollWheelZoom?: ZoomOption,\n  wheelDebounceTime?: number,\n  wheelPxPerZoomLevel?: number,\n  tap?: boolean,\n  tapTolerance?: number,\n  touchZoom?: ZoomOption,\n  bounceAtZoomLimits?: boolean,\n  // Additional options\n  animate?: boolean,\n  duration?: number,\n  noMoveStart?: boolean,\n  bounds?: LatLngBounds,\n  boundsOptions?: {|\n    paddingTopLeft?: Point,\n    paddingBottomRight?: Point,\n    padding?: Point,\n    maxZoom?: number,\n  |},\n  children: Node,\n  className?: string,\n  id?: string,\n  style?: Object,\n  useFlyTo?: boolean,\n  viewport?: Viewport,\n  whenReady?: () => void,\n}\n\nexport default class Map extends MapEvented<LeafletElement, Props> {\n  className: ?string\n  contextValue: ?LeafletContext\n  container: ?HTMLDivElement\n  viewport: Viewport = {\n    center: undefined,\n    zoom: undefined,\n  }\n\n  _ready: boolean = false\n  _updating: boolean = false\n\n  constructor(props: Props) {\n    super(props)\n    this.className = props.className\n  }\n\n  createLeafletElement(props: Props): LeafletElement {\n    const { viewport, ...options } = props\n    if (viewport) {\n      if (viewport.center) {\n        options.center = viewport.center\n      }\n      if (typeof viewport.zoom === 'number') {\n        options.zoom = viewport.zoom\n      }\n    }\n    return new LeafletMap(this.container, options)\n  }\n\n  updateLeafletElement(fromProps: Props, toProps: Props) {\n    this._updating = true\n\n    const {\n      bounds,\n      boundsOptions,\n      boxZoom,\n      center,\n      className,\n      doubleClickZoom,\n      dragging,\n      keyboard,\n      maxBounds,\n      scrollWheelZoom,\n      tap,\n      touchZoom,\n      useFlyTo,\n      viewport,\n      zoom,\n    } = toProps\n\n    updateClassName(this.container, fromProps.className, className)\n\n    if (viewport && viewport !== fromProps.viewport) {\n      const c = viewport.center ? viewport.center : center\n      const z = viewport.zoom == null ? zoom : viewport.zoom\n      if (useFlyTo === true) {\n        this.leafletElement.flyTo(c, z, this.getZoomPanOptions(toProps))\n      } else {\n        this.leafletElement.setView(c, z, this.getZoomPanOptions(toProps))\n      }\n    } else if (center && this.shouldUpdateCenter(center, fromProps.center)) {\n      if (useFlyTo === true) {\n        this.leafletElement.flyTo(center, zoom, this.getZoomPanOptions(toProps))\n      } else {\n        this.leafletElement.setView(\n          center,\n          zoom,\n          this.getZoomPanOptions(toProps),\n        )\n      }\n    } else if (typeof zoom === 'number' && zoom !== fromProps.zoom) {\n      if (fromProps.zoom == null) {\n        this.leafletElement.setView(\n          center,\n          zoom,\n          this.getZoomPanOptions(toProps),\n        )\n      } else {\n        this.leafletElement.setZoom(zoom, this.getZoomPanOptions(toProps))\n      }\n    }\n\n    if (maxBounds && this.shouldUpdateBounds(maxBounds, fromProps.maxBounds)) {\n      this.leafletElement.setMaxBounds(maxBounds)\n    }\n\n    if (\n      bounds &&\n      (this.shouldUpdateBounds(bounds, fromProps.bounds) ||\n        boundsOptions !== fromProps.boundsOptions)\n    ) {\n      if (useFlyTo === true) {\n        this.leafletElement.flyToBounds(\n          bounds,\n          this.getFitBoundsOptions(toProps),\n        )\n      } else {\n        this.leafletElement.fitBounds(bounds, this.getFitBoundsOptions(toProps))\n      }\n    }\n\n    if (boxZoom !== fromProps.boxZoom) {\n      if (boxZoom === true) {\n        this.leafletElement.boxZoom.enable()\n      } else {\n        this.leafletElement.boxZoom.disable()\n      }\n    }\n\n    if (doubleClickZoom !== fromProps.doubleClickZoom) {\n      if (doubleClickZoom === true) {\n        this.leafletElement.doubleClickZoom.enable()\n      } else {\n        this.leafletElement.doubleClickZoom.disable()\n      }\n    }\n\n    if (dragging !== fromProps.dragging) {\n      if (dragging === true) {\n        this.leafletElement.dragging.enable()\n      } else {\n        this.leafletElement.dragging.disable()\n      }\n    }\n\n    if (keyboard !== fromProps.keyboard) {\n      if (keyboard === true) {\n        this.leafletElement.keyboard.enable()\n      } else {\n        this.leafletElement.keyboard.disable()\n      }\n    }\n\n    if (scrollWheelZoom !== fromProps.scrollWheelZoom) {\n      if (scrollWheelZoom === true || typeof scrollWheelZoom === 'string') {\n        this.leafletElement.options.scrollWheelZoom = scrollWheelZoom\n        this.leafletElement.scrollWheelZoom.enable()\n      } else {\n        this.leafletElement.scrollWheelZoom.disable()\n      }\n    }\n\n    if (tap !== fromProps.tap) {\n      if (tap === true) {\n        this.leafletElement.tap.enable()\n      } else {\n        this.leafletElement.tap.disable()\n      }\n    }\n\n    if (touchZoom !== fromProps.touchZoom) {\n      if (touchZoom === true || typeof touchZoom === 'string') {\n        this.leafletElement.options.touchZoom = touchZoom\n        this.leafletElement.touchZoom.enable()\n      } else {\n        this.leafletElement.touchZoom.disable()\n      }\n    }\n\n    this._updating = false\n  }\n\n  getZoomPanOptions(props: Props) {\n    const { animate, duration, easeLinearity, noMoveStart } = props\n    return {\n      animate,\n      duration,\n      easeLinearity,\n      noMoveStart,\n    }\n  }\n\n  getFitBoundsOptions(props: Props) {\n    const zoomPanOptions = this.getZoomPanOptions(props)\n    return {\n      ...zoomPanOptions,\n      ...props.boundsOptions,\n    }\n  }\n\n  onViewportChange = () => {\n    const center = this.leafletElement.getCenter()\n    this.viewport = {\n      center: center ? [center.lat, center.lng] : undefined,\n      zoom: this.leafletElement.getZoom(),\n    }\n    if (this.props.onViewportChange && !this._updating) {\n      this.props.onViewportChange(this.viewport)\n    }\n  }\n\n  onViewportChanged = () => {\n    if (this.props.onViewportChanged && !this._updating) {\n      this.props.onViewportChanged(this.viewport)\n    }\n  }\n\n  componentDidMount() {\n    const props = omit(this.props, ...OTHER_PROPS)\n    this.leafletElement = this.createLeafletElement(props)\n\n    this.leafletElement.on('move', this.onViewportChange)\n    this.leafletElement.on('moveend', this.onViewportChanged)\n\n    if (props.bounds != null) {\n      this.leafletElement.fitBounds(\n        props.bounds,\n        this.getFitBoundsOptions(props),\n      )\n    }\n\n    this.contextValue = {\n      layerContainer: this.leafletElement,\n      map: this.leafletElement,\n    }\n\n    super.componentDidMount()\n    this.forceUpdate() // Re-render now that leafletElement is created\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (this._ready === false) {\n      this._ready = true\n      if (this.props.whenReady) {\n        this.leafletElement.whenReady(this.props.whenReady)\n      }\n    }\n\n    super.componentDidUpdate(prevProps)\n    this.updateLeafletElement(prevProps, this.props)\n  }\n\n  componentWillUnmount() {\n    super.componentWillUnmount()\n\n    this.leafletElement.off('move', this.onViewportChange)\n    this.leafletElement.off('moveend', this.onViewportChanged)\n\n    // The canvas renderer uses requestAnimationFrame, making a deferred call to a deleted object\n    // When preferCanvas is set, use simpler teardown logic\n    if (this.props.preferCanvas === true) {\n      this.leafletElement._initEvents(true)\n      this.leafletElement._stop()\n    } else {\n      this.leafletElement.remove()\n    }\n  }\n\n  bindContainer = (container: ?HTMLDivElement): void => {\n    this.container = container\n  }\n\n  shouldUpdateCenter(next: LatLng, prev: LatLng) {\n    if (!prev) return true\n    next = normalizeCenter(next)\n    prev = normalizeCenter(prev)\n    return next[0] !== prev[0] || next[1] !== prev[1]\n  }\n\n  shouldUpdateBounds(next: LatLngBounds, prev: LatLngBounds) {\n    return prev ? !latLngBounds(next).equals(latLngBounds(prev)) : true\n  }\n\n  render() {\n    return (\n      <div\n        className={this.className}\n        id={this.props.id}\n        ref={this.bindContainer}\n        style={this.props.style}>\n        {this.contextValue ? (\n          <LeafletProvider value={this.contextValue}>\n            {this.props.children}\n          </LeafletProvider>\n        ) : null}\n      </div>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}