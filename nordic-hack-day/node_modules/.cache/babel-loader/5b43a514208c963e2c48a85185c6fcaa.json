{"ast":null,"code":"import _objectWithoutProperties from \"/Users/n642407/Repos/NordicHackDay/nordic-hack-day/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"/Users/n642407/Repos/NordicHackDay/nordic-hack-day/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/Users/n642407/Repos/NordicHackDay/nordic-hack-day/src/Extra/LayersControl.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { Control } from 'leaflet';\nimport React, { cloneElement, Component, Children, Fragment } from 'react';\nimport { LeafletProvider, withLeaflet } from './context';\nimport MapControl from './MapControl';\n// Abtract class for layer container, extended by BaseLayer and Overlay\nexport class ControlledLayer extends Component {\n  componentDidUpdate({\n    checked\n  }) {\n    if (this.props.leaflet.map == null) {\n      return;\n    } // Handle dynamically (un)checking the layer => adding/removing from the map\n\n\n    if (this.props.checked === true && (checked == null || checked === false)) {\n      this.props.leaflet.map.addLayer(this.layer);\n    } else if (checked === true && (this.props.checked == null || this.props.checked === false)) {\n      this.props.leaflet.map.removeLayer(this.layer);\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.removeLayerControl(this.layer);\n  }\n\n  addLayer() {\n    throw new Error('Must be implemented in extending class');\n  }\n\n  removeLayer(layer) {\n    this.props.removeLayer(layer);\n  }\n\n  render() {\n    const children = this.props.children;\n    return children ? React.createElement(LeafletProvider, {\n      value: this.contextValue,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 68\n      },\n      __self: this\n    }, children) : null;\n  }\n\n}\n\nclass BaseLayer extends ControlledLayer {\n  constructor(props) {\n    super(props);\n\n    this.addLayer = layer => {\n      this.layer = layer; // Keep layer reference to handle dynamic changes of props\n\n      const _this$props = this.props,\n            addBaseLayer = _this$props.addBaseLayer,\n            checked = _this$props.checked,\n            name = _this$props.name;\n      addBaseLayer(layer, name, checked);\n    };\n\n    this.contextValue = _objectSpread({}, props.leaflet, {\n      layerContainer: {\n        addLayer: this.addLayer.bind(this),\n        removeLayer: this.removeLayer.bind(this)\n      }\n    });\n  }\n\n}\n\nclass Overlay extends ControlledLayer {\n  constructor(props) {\n    super(props);\n\n    this.addLayer = layer => {\n      this.layer = layer; // Keep layer reference to handle dynamic changes of props\n\n      const _this$props2 = this.props,\n            addOverlay = _this$props2.addOverlay,\n            checked = _this$props2.checked,\n            name = _this$props2.name;\n      addOverlay(layer, name, checked);\n    };\n\n    this.contextValue = _objectSpread({}, props.leaflet, {\n      layerContainer: {\n        addLayer: this.addLayer.bind(this),\n        removeLayer: this.removeLayer.bind(this)\n      }\n    });\n  }\n\n}\n\nclass LayersControl extends MapControl {\n  constructor(props) {\n    super(props);\n    this.controlProps = {\n      addBaseLayer: this.addBaseLayer.bind(this),\n      addOverlay: this.addOverlay.bind(this),\n      leaflet: props.leaflet,\n      removeLayer: this.removeLayer.bind(this),\n      removeLayerControl: this.removeLayerControl.bind(this)\n    };\n  }\n\n  createLeafletElement(props) {\n    const _children = props.children,\n          options = _objectWithoutProperties(props, [\"children\"]);\n\n    return new Control.Layers(undefined, undefined, options);\n  }\n\n  updateLeafletElement(fromProps, toProps) {\n    super.updateLeafletElement(fromProps, toProps);\n\n    if (toProps.collapsed !== fromProps.collapsed) {\n      if (toProps.collapsed === true) {\n        this.leafletElement.collapse();\n      } else {\n        this.leafletElement.expand();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    setTimeout(() => {\n      super.componentWillUnmount();\n    }, 0);\n  }\n\n  addBaseLayer(layer, name, checked = false) {\n    if (checked && this.props.leaflet.map != null) {\n      this.props.leaflet.map.addLayer(layer);\n    }\n\n    this.leafletElement.addBaseLayer(layer, name);\n  }\n\n  addOverlay(layer, name, checked = false) {\n    if (checked && this.props.leaflet.map != null) {\n      this.props.leaflet.map.addLayer(layer);\n    }\n\n    this.leafletElement.addOverlay(layer, name);\n  }\n\n  removeLayer(layer) {\n    if (this.props.leaflet.map != null) {\n      this.props.leaflet.map.removeLayer(layer);\n    }\n  }\n\n  removeLayerControl(layer) {\n    this.leafletElement.removeLayer(layer);\n  }\n\n  render() {\n    const children = Children.map(this.props.children, child => {\n      return child ? cloneElement(child, this.controlProps) : null;\n    });\n    return React.createElement(Fragment, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 189\n      },\n      __self: this\n    }, children);\n  }\n\n}\n\nconst LayersControlExport = withLeaflet(LayersControl);\nLayersControlExport.BaseLayer = BaseLayer;\nLayersControlExport.Overlay = Overlay;\nexport default LayersControlExport;","map":{"version":3,"sources":["/Users/n642407/Repos/NordicHackDay/nordic-hack-day/src/Extra/LayersControl.js"],"names":["Control","React","cloneElement","Component","Children","Fragment","LeafletProvider","withLeaflet","MapControl","ControlledLayer","componentDidUpdate","checked","props","leaflet","map","addLayer","layer","removeLayer","componentWillUnmount","removeLayerControl","Error","render","children","contextValue","BaseLayer","constructor","addBaseLayer","name","layerContainer","bind","Overlay","addOverlay","LayersControl","controlProps","createLeafletElement","_children","options","Layers","undefined","updateLeafletElement","fromProps","toProps","collapsed","leafletElement","collapse","expand","setTimeout","child","LayersControlExport"],"mappings":";;;;;;;;AAEA,SAASA,OAAT,QAAoC,SAApC;AACA,OAAOC,KAAP,IACEC,YADF,EAEEC,SAFF,EAGEC,QAHF,EAIEC,QAJF,QAOO,OAPP;AASA,SAASC,eAAT,EAA0BC,WAA1B,QAA6C,WAA7C;AACA,OAAOC,UAAP,MAAuB,cAAvB;AAmBA;AACA,OAAO,MAAMC,eAAN,SAA8BN,SAA9B,CAA8D;AAInEO,EAAAA,kBAAkB,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAoC;AACpD,QAAI,KAAKC,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,IAA0B,IAA9B,EAAoC;AAClC;AACD,KAHmD,CAIpD;;;AACA,QAAI,KAAKF,KAAL,CAAWD,OAAX,KAAuB,IAAvB,KAAgCA,OAAO,IAAI,IAAX,IAAmBA,OAAO,KAAK,KAA/D,CAAJ,EAA2E;AACzE,WAAKC,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,CAAuBC,QAAvB,CAAgC,KAAKC,KAArC;AACD,KAFD,MAEO,IACLL,OAAO,KAAK,IAAZ,KACC,KAAKC,KAAL,CAAWD,OAAX,IAAsB,IAAtB,IAA8B,KAAKC,KAAL,CAAWD,OAAX,KAAuB,KADtD,CADK,EAGL;AACA,WAAKC,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,CAAuBG,WAAvB,CAAmC,KAAKD,KAAxC;AACD;AACF;;AAEDE,EAAAA,oBAAoB,GAAG;AACrB,SAAKN,KAAL,CAAWO,kBAAX,CAA8B,KAAKH,KAAnC;AACD;;AAEDD,EAAAA,QAAQ,GAAG;AACT,UAAM,IAAIK,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAEDH,EAAAA,WAAW,CAACD,KAAD,EAAe;AACxB,SAAKJ,KAAL,CAAWK,WAAX,CAAuBD,KAAvB;AACD;;AAEDK,EAAAA,MAAM,GAAG;AAAA,UACCC,QADD,GACc,KAAKV,KADnB,CACCU,QADD;AAEP,WAAOA,QAAQ,GACb,oBAAC,eAAD;AAAiB,MAAA,KAAK,EAAE,KAAKC,YAA7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAA4CD,QAA5C,CADa,GAEX,IAFJ;AAGD;;AApCkE;;AAuCrE,MAAME,SAAN,SAAwBf,eAAxB,CAAwC;AACtCgB,EAAAA,WAAW,CAACb,KAAD,EAA8B;AACvC,UAAMA,KAAN;;AADuC,SAWzCG,QAXyC,GAW7BC,KAAD,IAAkB;AAC3B,WAAKA,KAAL,GAAaA,KAAb,CAD2B,CACR;;AADQ,0BAEa,KAAKJ,KAFlB;AAAA,YAEnBc,YAFmB,eAEnBA,YAFmB;AAAA,YAELf,OAFK,eAELA,OAFK;AAAA,YAEIgB,IAFJ,eAEIA,IAFJ;AAG3BD,MAAAA,YAAY,CAACV,KAAD,EAAQW,IAAR,EAAchB,OAAd,CAAZ;AACD,KAfwC;;AAEvC,SAAKY,YAAL,qBACKX,KAAK,CAACC,OADX;AAEEe,MAAAA,cAAc,EAAE;AACdb,QAAAA,QAAQ,EAAE,KAAKA,QAAL,CAAcc,IAAd,CAAmB,IAAnB,CADI;AAEdZ,QAAAA,WAAW,EAAE,KAAKA,WAAL,CAAiBY,IAAjB,CAAsB,IAAtB;AAFC;AAFlB;AAOD;;AAVqC;;AAmBxC,MAAMC,OAAN,SAAsBrB,eAAtB,CAAsC;AACpCgB,EAAAA,WAAW,CAACb,KAAD,EAA8B;AACvC,UAAMA,KAAN;;AADuC,SAWzCG,QAXyC,GAW7BC,KAAD,IAAkB;AAC3B,WAAKA,KAAL,GAAaA,KAAb,CAD2B,CACR;;AADQ,2BAEW,KAAKJ,KAFhB;AAAA,YAEnBmB,UAFmB,gBAEnBA,UAFmB;AAAA,YAEPpB,OAFO,gBAEPA,OAFO;AAAA,YAEEgB,IAFF,gBAEEA,IAFF;AAG3BI,MAAAA,UAAU,CAACf,KAAD,EAAQW,IAAR,EAAchB,OAAd,CAAV;AACD,KAfwC;;AAEvC,SAAKY,YAAL,qBACKX,KAAK,CAACC,OADX;AAEEe,MAAAA,cAAc,EAAE;AACdb,QAAAA,QAAQ,EAAE,KAAKA,QAAL,CAAcc,IAAd,CAAmB,IAAnB,CADI;AAEdZ,QAAAA,WAAW,EAAE,KAAKA,WAAL,CAAiBY,IAAjB,CAAsB,IAAtB;AAFC;AAFlB;AAOD;;AAVmC;;AAyBtC,MAAMG,aAAN,SAA4BxB,UAA5B,CAA2E;AAQzEiB,EAAAA,WAAW,CAACb,KAAD,EAA4B;AACrC,UAAMA,KAAN;AACA,SAAKqB,YAAL,GAAoB;AAClBP,MAAAA,YAAY,EAAE,KAAKA,YAAL,CAAkBG,IAAlB,CAAuB,IAAvB,CADI;AAElBE,MAAAA,UAAU,EAAE,KAAKA,UAAL,CAAgBF,IAAhB,CAAqB,IAArB,CAFM;AAGlBhB,MAAAA,OAAO,EAAED,KAAK,CAACC,OAHG;AAIlBI,MAAAA,WAAW,EAAE,KAAKA,WAAL,CAAiBY,IAAjB,CAAsB,IAAtB,CAJK;AAKlBV,MAAAA,kBAAkB,EAAE,KAAKA,kBAAL,CAAwBU,IAAxB,CAA6B,IAA7B;AALF,KAApB;AAOD;;AAEDK,EAAAA,oBAAoB,CAACtB,KAAD,EAA4C;AAAA,UAC5CuB,SAD4C,GAClBvB,KADkB,CACtDU,QADsD;AAAA,UAC9Bc,OAD8B,4BAClBxB,KADkB;;AAE9D,WAAO,IAAIZ,OAAO,CAACqC,MAAZ,CAAmBC,SAAnB,EAA8BA,SAA9B,EAAyCF,OAAzC,CAAP;AACD;;AAEDG,EAAAA,oBAAoB,CAClBC,SADkB,EAElBC,OAFkB,EAGlB;AACA,UAAMF,oBAAN,CAA2BC,SAA3B,EAAsCC,OAAtC;;AACA,QAAIA,OAAO,CAACC,SAAR,KAAsBF,SAAS,CAACE,SAApC,EAA+C;AAC7C,UAAID,OAAO,CAACC,SAAR,KAAsB,IAA1B,EAAgC;AAC9B,aAAKC,cAAL,CAAoBC,QAApB;AACD,OAFD,MAEO;AACL,aAAKD,cAAL,CAAoBE,MAApB;AACD;AACF;AACF;;AAED3B,EAAAA,oBAAoB,GAAG;AACrB4B,IAAAA,UAAU,CAAC,MAAM;AACf,YAAM5B,oBAAN;AACD,KAFS,EAEP,CAFO,CAAV;AAGD;;AAEDQ,EAAAA,YAAY,CAACV,KAAD,EAAeW,IAAf,EAA6BhB,OAAgB,GAAG,KAAhD,EAAuD;AACjE,QAAIA,OAAO,IAAI,KAAKC,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,IAA0B,IAAzC,EAA+C;AAC7C,WAAKF,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,CAAuBC,QAAvB,CAAgCC,KAAhC;AACD;;AACD,SAAK2B,cAAL,CAAoBjB,YAApB,CAAiCV,KAAjC,EAAwCW,IAAxC;AACD;;AAEDI,EAAAA,UAAU,CAACf,KAAD,EAAeW,IAAf,EAA6BhB,OAAgB,GAAG,KAAhD,EAAuD;AAC/D,QAAIA,OAAO,IAAI,KAAKC,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,IAA0B,IAAzC,EAA+C;AAC7C,WAAKF,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,CAAuBC,QAAvB,CAAgCC,KAAhC;AACD;;AACD,SAAK2B,cAAL,CAAoBZ,UAApB,CAA+Bf,KAA/B,EAAsCW,IAAtC;AACD;;AAEDV,EAAAA,WAAW,CAACD,KAAD,EAAe;AACxB,QAAI,KAAKJ,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,IAA0B,IAA9B,EAAoC;AAClC,WAAKF,KAAL,CAAWC,OAAX,CAAmBC,GAAnB,CAAuBG,WAAvB,CAAmCD,KAAnC;AACD;AACF;;AAEDG,EAAAA,kBAAkB,CAACH,KAAD,EAAe;AAC/B,SAAK2B,cAAL,CAAoB1B,WAApB,CAAgCD,KAAhC;AACD;;AAEDK,EAAAA,MAAM,GAAG;AACP,UAAMC,QAAQ,GAAGlB,QAAQ,CAACU,GAAT,CAAa,KAAKF,KAAL,CAAWU,QAAxB,EAAkCyB,KAAK,IAAI;AAC1D,aAAOA,KAAK,GAAG7C,YAAY,CAAC6C,KAAD,EAAQ,KAAKd,YAAb,CAAf,GAA4C,IAAxD;AACD,KAFgB,CAAjB;AAGA,WAAO,oBAAC,QAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAWX,QAAX,CAAP;AACD;;AAzEwE;;AA4E3E,MAAM0B,mBAA2B,GAAGzC,WAAW,CAACyB,aAAD,CAA/C;AAEAgB,mBAAmB,CAACxB,SAApB,GAAgCA,SAAhC;AACAwB,mBAAmB,CAAClB,OAApB,GAA8BA,OAA9B;AAEA,eAAekB,mBAAf","sourcesContent":["// @flow\n\nimport { Control, type Layer } from 'leaflet'\nimport React, {\n  cloneElement,\n  Component,\n  Children,\n  Fragment,\n  type ChildrenArray,\n  type Element,\n} from 'react'\n\nimport { LeafletProvider, withLeaflet } from './context'\nimport MapControl from './MapControl'\nimport type {\n  AddLayerHandler,\n  RemoveLayerHandler,\n  LeafletContext,\n  MapControlProps,\n} from './types'\n\ntype ControlledLayerProps = {\n  addBaseLayer: AddLayerHandler,\n  addOverlay: AddLayerHandler,\n  checked?: boolean,\n  children: Element<*>,\n  leaflet: LeafletContext,\n  name: string,\n  removeLayer: RemoveLayerHandler,\n  removeLayerControl: RemoveLayerHandler,\n}\n\n// Abtract class for layer container, extended by BaseLayer and Overlay\nexport class ControlledLayer extends Component<ControlledLayerProps> {\n  contextValue: LeafletContext\n  layer: ?Layer\n\n  componentDidUpdate({ checked }: ControlledLayerProps) {\n    if (this.props.leaflet.map == null) {\n      return\n    }\n    // Handle dynamically (un)checking the layer => adding/removing from the map\n    if (this.props.checked === true && (checked == null || checked === false)) {\n      this.props.leaflet.map.addLayer(this.layer)\n    } else if (\n      checked === true &&\n      (this.props.checked == null || this.props.checked === false)\n    ) {\n      this.props.leaflet.map.removeLayer(this.layer)\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.removeLayerControl(this.layer)\n  }\n\n  addLayer() {\n    throw new Error('Must be implemented in extending class')\n  }\n\n  removeLayer(layer: Layer) {\n    this.props.removeLayer(layer)\n  }\n\n  render() {\n    const { children } = this.props\n    return children ? (\n      <LeafletProvider value={this.contextValue}>{children}</LeafletProvider>\n    ) : null\n  }\n}\n\nclass BaseLayer extends ControlledLayer {\n  constructor(props: ControlledLayerProps) {\n    super(props)\n    this.contextValue = {\n      ...props.leaflet,\n      layerContainer: {\n        addLayer: this.addLayer.bind(this),\n        removeLayer: this.removeLayer.bind(this),\n      },\n    }\n  }\n\n  addLayer = (layer: Layer) => {\n    this.layer = layer // Keep layer reference to handle dynamic changes of props\n    const { addBaseLayer, checked, name } = this.props\n    addBaseLayer(layer, name, checked)\n  }\n}\n\nclass Overlay extends ControlledLayer {\n  constructor(props: ControlledLayerProps) {\n    super(props)\n    this.contextValue = {\n      ...props.leaflet,\n      layerContainer: {\n        addLayer: this.addLayer.bind(this),\n        removeLayer: this.removeLayer.bind(this),\n      },\n    }\n  }\n\n  addLayer = (layer: Layer) => {\n    this.layer = layer // Keep layer reference to handle dynamic changes of props\n    const { addOverlay, checked, name } = this.props\n    addOverlay(layer, name, checked)\n  }\n}\n\ntype LeafletElement = Control.Layers\ntype LayersControlProps = {\n  children: ChildrenArray<*>,\n  collapsed?: boolean,\n} & MapControlProps\n\nclass LayersControl extends MapControl<LeafletElement, LayersControlProps> {\n  controlProps: {\n    addBaseLayer: AddLayerHandler,\n    addOverlay: AddLayerHandler,\n    removeLayer: RemoveLayerHandler,\n    removeLayerControl: RemoveLayerHandler,\n  }\n\n  constructor(props: LayersControlProps) {\n    super(props)\n    this.controlProps = {\n      addBaseLayer: this.addBaseLayer.bind(this),\n      addOverlay: this.addOverlay.bind(this),\n      leaflet: props.leaflet,\n      removeLayer: this.removeLayer.bind(this),\n      removeLayerControl: this.removeLayerControl.bind(this),\n    }\n  }\n\n  createLeafletElement(props: LayersControlProps): LeafletElement {\n    const { children: _children, ...options } = props\n    return new Control.Layers(undefined, undefined, options)\n  }\n\n  updateLeafletElement(\n    fromProps: LayersControlProps,\n    toProps: LayersControlProps,\n  ) {\n    super.updateLeafletElement(fromProps, toProps)\n    if (toProps.collapsed !== fromProps.collapsed) {\n      if (toProps.collapsed === true) {\n        this.leafletElement.collapse()\n      } else {\n        this.leafletElement.expand()\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    setTimeout(() => {\n      super.componentWillUnmount()\n    }, 0)\n  }\n\n  addBaseLayer(layer: Layer, name: string, checked: boolean = false) {\n    if (checked && this.props.leaflet.map != null) {\n      this.props.leaflet.map.addLayer(layer)\n    }\n    this.leafletElement.addBaseLayer(layer, name)\n  }\n\n  addOverlay(layer: Layer, name: string, checked: boolean = false) {\n    if (checked && this.props.leaflet.map != null) {\n      this.props.leaflet.map.addLayer(layer)\n    }\n    this.leafletElement.addOverlay(layer, name)\n  }\n\n  removeLayer(layer: Layer) {\n    if (this.props.leaflet.map != null) {\n      this.props.leaflet.map.removeLayer(layer)\n    }\n  }\n\n  removeLayerControl(layer: Layer) {\n    this.leafletElement.removeLayer(layer)\n  }\n\n  render() {\n    const children = Children.map(this.props.children, child => {\n      return child ? cloneElement(child, this.controlProps) : null\n    })\n    return <Fragment>{children}</Fragment>\n  }\n}\n\nconst LayersControlExport: Object = withLeaflet(LayersControl)\n\nLayersControlExport.BaseLayer = BaseLayer\nLayersControlExport.Overlay = Overlay\n\nexport default LayersControlExport\n"]},"metadata":{},"sourceType":"module"}